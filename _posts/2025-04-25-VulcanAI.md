---
title: VulcanAI
description: Basic things work. Now what?
categories: [Projects, Programming]
tags: [VulcanAI, AI]
mermaid: true
---

# VulcanAI

## Basic things work. Now what?

Progress has been coming along well with [VulcanAI](https://stevengann.com/VulcanAI/), with [ObsidianDB](https://stevengann.com/ObsidianDB/) becoming more functional and [HyperVectorDB](https://stevengann.com/HyperVectorDB/) being functionally complete, which brings me a few steps closer to my ambitions I talk about in [the overarcing project page](https://stevengann.com/projects/knowledgebase-ai.html). 

Now is a good time to stop and seriously think about the architecture of the the VulcanAI project, and how to proceed towards its design goals. In the readme, I talk about it being modular and providing a Lego-like experience to building AI applications, but right now it is actually rather monolithic and a lot of behavior is hardcoded. If I am going to meet the goals I set out, I need to reconsider how the project is organized and how the functional logic is implemented.

## Organization

In the ideal future, VulcanAI is an ecosystem of packages. You add the VulcanAI package that includes the Core namespace and some other common classes and interfaces, but then you add some combination of additional packages that bring the functionality you need while adding minimal dependencies that you don't. The Discord interface should be its own package, for example. So should the Discord interface. I have grand plans for classes to support MPC, databases like SQL, IRC, web scraping, social media like Reddit and Twitter, automation tools like MQTT, etc. Since these would each bring new dependencies and almost no application will need _all_ of them, they should all be split up into their own packages, enstilling a robustly modular, Lego-like approach.

In practice, splitting everything up into multiple packages while everything is in heavy development adds a _lot_ of extra hassle and overhead. For now, everything will need to stay bundled in the VulcanAI repository as a single package, but the design needs to keep everything isolated as much as possible. I could probably split off the Discord and Obsidian functionality into their own projects in the same solution without too much overhead, and it would help enforce good isolation practices going forward.

## Logic

Right now, the biggest part of the VulcanAI core is the [`Agent` class](https://stevengann.com/VulcanAI/api/VulcanAI.Core.Agent.Agent.html) which is uncomfortably a black box. It has all of its logic totally hardcoded to function as a basic chat bot. It is fortunately agnostic in that it uses interfaces for its interactions with the Discord and Obsidian functionality, but the hardcoded logic loop is unacceptable.

I can see utility in having a class that implements a basic chat bot like this, as well as other common agent designs, so it makes me think the `Agent` class should be replaced with an `IAgent` interface and the existing `Agent` class refactored to be `ChatbotAgent` that implements `IAgent`. The idea has me thinking of what other `IAgent` classes might be worth bundling.

- `AnalysisAgent` that takes a template and a prompt, analyzes whatever knowledge sources it is provided, and emits a report based on the template?
- `ScriptedAgent` that exposes the whole `Agent` API and all the knowledge sources and interfaces it has been provided to a scripting engine that handles the high level logic? Since performance isn't critical at that level any embeddable scripting language would suffice but this sounds like a good application for Lua.

Adding dynamic scripting is an important step towards my goal of an AI agent that can improve itself over time, add new functionality autonomously, etc. Anything that avoids having to kill the process, recompile, and restart helps towards that, and low-code functionality is a way to do that. At least, minimal C# code. If an agent could be defined entirely in JSON or XML and that definition reloaded without stopping the main executable, it would provide smoother development of agents while also empowering realtime AI generation of agents and even self-modification for agents.